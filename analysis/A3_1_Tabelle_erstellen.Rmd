---
title: "3. Tabelle erstellen für einen gewählten Satz Spinat"
author: "Samantha Rubo"
date: '2021-12-10'
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(data.table)
library(dplyr)
library(ggplot2)
library(lubridate)
library(ggnewscale)
library(tidyr)
library(DBI)
library(purrr)
```

#Wetter-Daten aus DB auslesen:
```{r}
path0 <- "GeoSenSys2020/Data_2020/Database_Protokolle/Database_CSV_Tabellen_HGU/HGU_GeoSenSys_V3_6.db"
# Verbindung zur Datenbanl herstellen:
path1 <- ifelse(Sys.info()["user"] == "samantha_machgu",
                "~/Documents/Mac_Github/", 
                "../../"
)
db <- paste0(path1, path0) # DB in other R-Project

db1 <- dbConnect(RSQLite::SQLite(), db)

query2 <- "SELECT *  FROM Wetter;"
wetter <- dbGetQuery(db1, query2) %>% # Niederschlag aller Saetze einlesen
    mutate_at("datum_wetter", ~data.table::as.IDate(.)) %>% 
    mutate_at("datum_wetter", ~as_date(.)) %>%
    arrange(wetter_id)
dbDisconnect(db1)
rm(query2)
names(wetter)

# als csv speichern:
fwrite(x = wetter, file = "../data/derived_data/wetter_2020_2022_20220805.csv", sep = ";")
```

#Tensio einlesen:
```{r}
# tensio <- fread("../data/derived_data/nfK_2020_2022_20220805_10cm_Schritte.csv") %>%
#     mutate_at("zeit_messung", ~as_date(.))
tensio <- fread("../data/derived_data/nfK_2020_2022_20220805.csv") %>%
    mutate_at("zeit_messung", ~as_date(.))
```

#bewaesserung einlesen:
```{r}
bewaesserung <- fread("../data/derived_data/bewaesserung_2020_2022_20220805.csv") %>%
    mutate_at("datum_bewaesserung", ~as_date(.)) %>%
    as_tibble()
```

#Alle Tabellen joinen:
```{r}
input_tabelle <- tensio %>% 
    left_join(bewaesserung, by = c("satz_id", "variante_H2O", "wiederholung",
                                   "zeit_messung" = "datum_bewaesserung")) %>%
    left_join(wetter, by = c("satz_id","zeit_messung" = "datum_wetter")) %>%
    mutate_at("bewaesserung_mm", ~ifelse(is.na(.), 0, .))
```


### Wasserhaltevermögen der Felder der HGU:
|Schicht Nr.|Bezeichnung|100%nFK entsprechen|"Wassergehalt (Vol.% bei 100%nFK)"|
|:---------:|:---------:|:-----------------:|:--------------------------------:|
|   1       |	0-30 cm	|       49.3 mm     |	            16.4%              |
|   2       |  30-60 cm |       46.1 mm     |	            15.4%              |
|   3       |  60-90 cm |       43.4 mm     |               14.5%              |


\
#Fehlende Werte approximieren:
```{r}
input_tabelle <- input_tabelle %>%
    group_by(satz_id, variante_H2O, wiederholung) %>%
    #Fehlende Werte Approximieren:
    mutate(across(.cols = contains("nFK"), 
                 # ~zoo::na.approx(., na.rm = FALSE))
           ~stats::approx(x = ., n = n(), rule = 2, method = "linear")$y)
           #~Hmisc::approxExtrap(x = 1:n(), y=.x, xout = 1:n(), na.rm = T, rule=2, method = "constant")$y
    )
```


## Bodenart anfuegen
```{r}
input_tabelle <- input_tabelle %>% 
    mutate(Ton_prozent = 20,
           Schluff_prozent = 30,
           Sand_prozent = 50,
           C_org_prozent = 1.2)
```

## ISARIA-Daten anfügen
```{r, eval=FALSE}
db1 <- dbConnect(RSQLite::SQLite(), db)
isaria <- dbGetQuery(db1, "SELECT
                     Spinat_Saetze.satz_id,
                     ISARIA_N.datum_messung,
                     Varianten.variante_H2O,
                     Parzellen.wiederholung,
                     ISARIA_N.ibi,
                     ISARIA_N.irmi
                     FROM ISARIA_N

                     LEFT JOIN Parzellen ON ISARIA_N.parzelle_id = Parzellen.parzelle_id
                     LEFT JOIN Varianten ON Parzellen.variante_id = Varianten.variante_id
                     LEFT JOIN Spinat_Saetze ON Varianten.satz_id = Spinat_Saetze.satz_id;") %>%
    mutate_at("datum_messung", ~as_date(.))
dbDisconnect(db1)

#Mittelwert pro Parzelle Messzeitpunkt
isaria <- isaria %>%
    group_by(satz_id, variante_H2O, wiederholung, datum_messung) %>%
    summarise(across(ibi:irmi, ~mean(., na.rm=TRUE)), .groups = "drop") %>%
    mutate_if(is.numeric, ~round(., 2))


# #NEU: smoothed data aus Auswertung verwenden!
# isaria <- fread("../../GeoSenSys2020/Auswertung_Saetze/ISARIA_Alignment/HGU_ISARIA_extrapolated_smoothed.csv") %>%
#      mutate_at("datum_messung", ~as_date(.))
```


#Isaria: Interpolation zwischen den Messtagen:
```{r, eval=FALSE}
input_tabelle <- input_tabelle %>% 
    left_join(isaria, by = c("satz_id", "variante_H2O", "wiederholung", "zeit_messung" = "datum_messung")) %>% 
    group_by(satz_id, variante_H2O, wiederholung) %>%
    #Werte vor der ersten ISARIA-Messung werden gelöscht (keine Interpolation möglich)
    mutate(delete_leading_NA = ifelse(is.na(ibi), 0, 1) %>% cumsum(.) %>% cumsum(.)) %>%
    filter(delete_leading_NA > 0) %>%
    select(-delete_leading_NA) %>%
    filter(satz_id > 2) %>%
    group_by(satz_id, variante_H2O, wiederholung) %>%
    mutate(across(ibi:irmi,~approx(x=., method = "linear", rule = 1, n = n())$y)) %>%
    ungroup

# ggplot(input_plus_isaria, aes(tage_seit_aussaat, ibi, 
#                               col = as.factor(satz_id), linetype = variante_H2O)) +
# stat_summary(fun = "mean", geom = "line")
```
\

# ISARIA V2: berechnen:
```{r}
ymin = 5 #nls um 5 nach oben schieben (minimalwert bei fitting geht durch 0)

input_tabelle <- input_tabelle %>%
    mutate(dae_geschaetzt = 14/(1 + exp((11 - Tmean_th9_25_gradC)/-3)), 
           .after = "zeit_messung") %>% 
    #Modell händisch angepasst (da wenige Daten)
    #nicht Tmean_th9_25_gradC_sum, sondern tages mittelwert!, da fitting auf mittelwerten (namen dabei nicht angepasst)
    mutate(across("dae_geschaetzt", ~ceiling(.+ymin))) %>%
    #Mittelwerte der geschätzen DAE seit Aussaat:
    mutate(dae_geschaetzt_mittel = cumsum(dae_geschaetzt) / tage_seit_aussaat, .after = "dae_geschaetzt") %>%
    #select(datum, tage_seit_aussaat, dae_geschaetzt, dae_geschaetzt_mittel) %>%
    mutate(dae_erreicht = ifelse(dae_geschaetzt_mittel < tage_seit_aussaat, 1, 0)) %>%
    mutate(dae = cumsum(dae_erreicht)) %>%
    select(-dae_geschaetzt, -dae_erreicht, -dae_geschaetzt_mittel)


#IBI und IRMI berechnen:
#ibi = 4.12/(1 + exp((198.135 - tageslicht_h_th9_sum_dae)/63.903)) 
#irmi = 26.947/(1 + exp((95.968 - tageslicht_h_th9_sum_dae)/224.165))

input_tabelle <- input_tabelle %>%
    ## tageslicht_h_th9_sum_dae berechnen:
    mutate(tageslicht_h_th9_sum_dae = cumsum(ifelse(dae > 0, tageslicht_h_th9, 0))) %>%
    mutate(ibi = 4.12/(1 + exp((198.135 - tageslicht_h_th9_sum_dae)/63.903)),
           irmi = 26.947/(1 + exp((95.968 - tageslicht_h_th9_sum_dae)/224.165))) %>%
    select(-dae, -tageslicht_h_th9_sum_dae)

```

### nFK vom Vortag als Input ausweisen:
```{r}
input_tabelle <- 
    input_tabelle  %>%
    # mutate(across(c("nFK_0010","nFK_1020","nFK_2030","nFK_3040","nFK_4050","nFK_5060"),
    #               ~c(NA,.[1:(n()-1)]) ,
    #               .names = "{.col}_Vortag")
    # )
    mutate(across(c("T0020_nFK", "T2040_nFK", "T4060_nFK"),
                  ~c(NA,.[1:(n()-1)]) ,
                  .names = "{.col}_Vortag")
    )
```
\
### Wassereintrag aus P + Bewässerung berechnen. 
```{r}
input_tabelle <- input_tabelle %>% 
    rowwise() %>%
    mutate(wasser_input = sum(niederschlag_mm, bewaesserung_mm, na.rm = TRUE)) %>%
    ungroup %>%
    mutate(wasser_input_Vortag = c(NA,wasser_input[1:(n()-1)]))
```

# neu: nur trockene Sätze auswählen:
```{r}
input_tabelle <- 
    input_tabelle  %>%
    #filter(variante_H2O == "Wfull") %>%
    group_by(satz_id, variante_H2O, wiederholung, tage_seit_aussaat) %>%
    select(where(is.numeric)) %>%
    #summarise(across(everything(), ~mean(., na.rm = T))) %>% #Mittelwert der Varianten erstellen
    #filter(satz_id %in% c(3,5,8)) %>% #relativ trockene Sätze
    ungroup()
```


#Benötigte Variablen selektieren.
```{r}
# für MLP:
input_tabelle_final <- 
    input_tabelle  %>%
    #raus soll:
    select(-niederschlag_mm, -bewaesserung_mm, 
           #-wasser_input, belassen für LSTM
           -wetter_id, -FAO56_mm, -FAO56_mm_sum, -par_Wh_m2,  
           #par_Wh_m2 raus, da bei vielen Stationen nicht enthalten
           -starts_with("bodensaugspannung"), -starts_with("pf")
    ) %>%
    #sortierung der Spalten:
    select(satz_id, variante_H2O, wiederholung, contains("nFK"), !contains("nFK")) #%>% 
#tidyr::drop_na() #für LSTM herausnehmen. Bis hierhin sind die Zeitreihen vollständig (alle Tage vorhanden)



## für LSTM:
# input_tabelle <-
#     input_tabelle  %>%
#     select(-niederschlag_mm, -bewaesserung_mm,
#            -wetter_id, -FAO56_mm, -FAO56_mm_sum, -par_Wh_m2
#     ) %>%
#     #par_Wh_m2 raus, da bei vielen Stationen nicht enthalten
#     select(satz_id, wiederholung, variante_H2O, contains("nFK"), !contains("nFK"))
```


# LSTM-Anpassung

## Spalten wählen und NA entfernen:
```{r}
input_tabelle <- input_tabelle %>% 
    select(-ends_with("Vortag"),  #ohne Vortag, da Zeitreihe nachträglich
           -starts_with(c("bodensaugspannung_","pf_")))

# NA passgenau entfernen:
input_tabelle <- input_tabelle %>% 
    filter(if_all(ends_with("_nFK"), ~!is.na(.))) %>% 
    filter(satz_id != 5 | tage_seit_aussaat <42) %>%
    filter(satz_id != 8 | tage_seit_aussaat <46) 
# filter(if_any(everything(), ~is.na(.)))

```


## Gleiches Intervall für LSTM-Anni (14 Tage)
```{r}
i1 <- input_tabelle %>% 
    group_by(satz_id, variante_H2O, wiederholung) %>%
    mutate(id = cur_group_id(), .after = "variante_H2O") %>%
    group_by(id) %>%
    #select(-satz_id, -variante_H2O, -wiederholung) %>%
    mutate(nn = n()) %>% filter(nn >= 14) 

# i14plus <- i1 %>% filter(between(nn,15, 30))
i30plus <- i1 %>% filter(nn > 30)

idx1 <- 1:14
idx2 <- max(idx1)-1
idx3 <- 10:23

list_df1 <- map_df(list(#"1"=i14plus,
                        "2"=i30plus ), 
                   ~.x %>% slice(idx1) %>%
                       mutate(nx = 1:n()), .id = "list_nr"
)

list_df2 <- map_df(list(#"3"=i14plus, 
                        "4"=i30plus ), 
                   ~.x %>% slice((n()-idx2):n()), .id = "list_nr"
)

list_df3 <- i30plus %>% slice(idx3) %>% mutate(list_nr = "5")

sliced_together <- bind_rows(list_df1, list_df2, list_df3) %>% 
    group_by(list_nr, id) %>%
    mutate(id_all = cur_group_id(), .before = "list_nr") %>%
    group_by(id_all) %>% 
    select(-list_nr, -id, -nn, -nx)

#sliced_together %>% group_by(id_all) %>% summarise(nn = n())

rm(list_df1, list_df2, list_df3, i1, i14plus, i30plus, idx1, idx2, idx3)  
```

```{r}
input_tabelle_final <- sliced_together
```


### Tabelle speichern on Projekt-Ordner für Daten
```{r}
# write.table(x = input_tabelle_final,
#             file = paste0("../data/derived_data/",
#             #"input_tabelle_2020_2022_20231101_20cm_LSTM_complete_id.csv"),
#             "input_tabelle_2020_2022_20231113_20cm_complete_mitNA.csv"),
#             sep = ";",dec = ".", row.names = FALSE)
```



## Visuelle Prüfung:
```{r}
p1 <- ggplot(input_tabelle_final %>% select(satz_id, variante_H2O, wiederholung, tage_seit_aussaat, ends_with("nFK")) %>% pivot_longer(cols = ends_with("nFK")), 
       aes(x = tage_seit_aussaat, y=value,
                                col = variante_H2O, linetype = wiederholung)) + 
    geom_line() + 
    facet_grid(name~satz_id)

p1

p2 <- ggplot(input_tabelle_final %>% select(satz_id, variante_H2O, wiederholung, tage_seit_aussaat, ibi, irmi) %>% pivot_longer(cols = ibi:irmi), 
       aes(x = tage_seit_aussaat, y=value,
                                col = variante_H2O, linetype = wiederholung)) + 
    geom_line() + 
    facet_grid(name~satz_id, scales = "free_y")
p2
```
```{r}
#?
input_tabelle_final %>% group_by(satz_id, variante_H2O) %>% summarise(min1 = min(tage_seit_aussaat))
```

