---
title: "ANNI_0 erstellen"
author: "Samantha Rubo"
date: '2021-12-15'
output: html_notebook
---
```{r}
rm(list = ls())
```
\
### Bibliotheken laden
```{r message=FALSE, warning=FALSE, include=FALSE}
library(data.table)
library(dplyr)
library(ggplot2)
library(lubridate)
#library(ggnewscale)
#library(tidyr)
library(neuralnet)
library(keras)
```
\
### Input-Tabelle laden (aus A3_Tabelle_erstellen.RMD)
```{r}
input_tabelle <- data.table::fread(
    "../data/derived_data/input_tabelle_2020_2021_20220315.csv", 
    sep = ";", dec = ".") %>% as_tibble()
```
\
### nFK vom Vortag als Input ausweisen:
```{r}
input_tabelle <- 
    input_tabelle %>%
    mutate(T0020_nFK_Vortag = c(NA,T0020_nFK[1:(n()-1)]),
           T2040_nFK_Vortag = c(NA,T2040_nFK[1:(n()-1)]),
           T4060_nFK_Vortag = c(NA,T4060_nFK[1:(n()-1)])) #%>%
# slice(-1) #erste Zeile entfernt, da hier NA
```
\
### Wassereintrag aus P + Bewässerung berechnen. Benötigte Variablen selektieren.
```{r}
target <- c("tage_seit_aussaat", 
            "bewaesserung_mm", "Tempsum", "Tmax_gradC", "Tmin_gradC", "Tmean_gradC", 
            "relLuftfeuchte_mean_prozent", "relLuftfeuchte_min_prozent", 
            "Gobsum", "globalstrahlung_Mj_m2", "niederschlag_mm", 
            "windgeschwindigkeit_m_s", "FAO56_mm", 
            #"T0020_mm", "T2040_mm", "T4060_mm", 
            "T0060_mm",
            "T0020_nFK_Vortag", "T2040_nFK_Vortag", "T4060_nFK_Vortag")
input_df <- input_tabelle %>% #[1:100,] %>%
    select(satz_id, variante_H2O, target) %>%
    rowwise() %>%
    mutate(wasser_input = sum(niederschlag_mm, bewaesserung_mm, na.rm = TRUE)) %>%
    ungroup %>%
    mutate(wasser_input_Vortag = c(NA,wasser_input[1:(n()-1)])) %>%
    select(-niederschlag_mm, -bewaesserung_mm, -wasser_input) %>%
    tidyr::drop_na()

idx_saetze <- input_df %>% select(satz_id, variante_H2O)
input_df <- input_df %>% select(-satz_id, -variante_H2O)

```
\

# Keras Tensorflow
```{r}
target_x <- c("tage_seit_aussaat",
              "Tempsum",
              "Tmax_gradC" ,
              "Tmin_gradC",
              "Tmean_gradC",
              "relLuftfeuchte_mean_prozent",
              "relLuftfeuchte_min_prozent",
              "Gobsum",
              "globalstrahlung_Mj_m2",
              "windgeschwindigkeit_m_s",
              "T0020_nFK_Vortag",
              "T2040_nFK_Vortag",
              "T4060_nFK_Vortag",           
              "wasser_input_Vortag"  )

target_y <- "T0060_mm" 

idx1 <- match(target_x,names(input_df))
idx2 <- match(target_y,names(input_df))

```


```{r}
data <- as.matrix(input_df[,c(idx2, idx1)])
dimnames(data) <- NULL
```


```{r}
set.seed(123)
ind <- sample(2, nrow(data), replace = T, prob = c(.7, .3))
training <- data[ind==1,2:ncol(data)]
test <- data[ind==2, 2:ncol(data)]
trainingtarget <- data[ind==1, 1]
testtarget <- data[ind==2,1]
str(trainingtarget)
str(testtarget)
```
```{r}
m <- colMeans(training)
s <- apply(training, 2, sd)
training <- scale(training, center = m, scale = s)
test <- scale(test, center = m, scale = s)
```

```{r}
model <- keras::keras_model_sequential()
model %>%
    layer_dense(units = 5, activation = 'sigmoid', input_shape = c(10,4)) %>%
    layer_dense(units = 1)
```

```{r}
model %>% compile(loss = 'mse',
                  optimizer = 'rmsprop',
                  metrics = 'mae')
```

```{r}
mymodel <- model %>%
    fit(training,trainingtarget,
        epochs = 100,
        batch_size = 32,
        validation_split = 0.2)
```

```{r}
model %>% evaluate(test, testtarget)
pred <- model %>% predict(test)
mean((testtarget-pred)^2)
```
```{r}
plot(testtarget, pred)
```
Modell speichern:
For Sequential Models and models built using the Functional API use:

save_model_hdf5()/load_model_hdf5() 
    to save the entire model to disk, including the optimizer state. 
    You can also use save_model_tf/load_model_tf to save the entire model to the SavedModel format.

get_config()/from_config() 
    to load only the model architecture into an R object.

model_to_json()/model_from_json() 
    to save only the architecture of the model to a single string.
    useful for saving the architecture to disk. 
    You can also use model_to_yaml()/model_from_yaml() to save the architecture.

save_model_weights_hdf5()/load_model_weights_hdf5() 
    if you want to save only the model weights to disk in the hdf5 format. 
    You can also use save_model_weights_tf()/load_model_weights_tf() to save the weights in the SavedModel format.

```{r}
# Save entire model to the SavedModel format
model %>% save_model_tf("Model1/")

save_model_hdf5(model, "model.h5")
```

Saved Model
A SavedModel contains a complete TensorFlow program, including weights and computation. It does not require the original model building code to run, which makes it useful for sharing or deploying (with TFLite, TensorFlow.js, TensorFlow Serving, or TensorFlow Hub).


#V4

```{r}
model <- keras::keras_model_sequential()

model %>%
    layer_dense(units = 20, activation = 'relu', input_shape = c(12)) %>%
    layer_dropout(rate=0.4)  %>%
    layer_dense(units = 50, activation = 'relu')  %>%
    layer_dropout(rate=0.2)  %>%
    layer_dense(units = 20, activation = 'relu')  %>%
    layer_dropout(rate=0.2)  %>%
    layer_dense(units = 1)
```

```{r}
model %>% compile(loss = 'mse',
                  optimizer = 'rmsprop',
                  metrics = 'mae')
```

```{r message=FALSE, include=FALSE}
mymodel <- model %>%
    fit(training,trainingtarget,
        epochs = 100,
        batch_size = 32,
        validation_split = 0.2)
```

```{r}
model %>% evaluate(test, testtarget)
pred <- model %>% predict(test)
mean((testtarget-pred)^2)
```
```{r}
plot(testtarget, pred)
```


